# dagster-trino Usage Examples

## Instructions

The examples contained in this folder showcase several usage patterns for dagster-trino. 

The examples can be run from the dagit UI by executing the following command from the `examples` folder:

```shell
dagit -w workspace.yaml
```

To load only selected examples, comment or remove examples that should not be loaded from the `worskpace.yaml` file. For example the following file will instruct dagit to only load examples from the `examples/0_basic_resource` folder:

```yaml
load_from:
  - python_module: 0_basic_resource
  #- python_module: 1_io_manager
  #- python_module: 2_custom_dataframe_integrations
  ```

## Examples

The modules listed in this folder showcase different ways you can leverage `dagster-trino`:

### Using a Trino Resource

The [Basic Resource](0_basic_resource/) module shows the simplest way `dagster-trino` can be used, that is, leveraging a raw `trino` resource. Using the resource, Dagster manages the Trino connection and configuration, but the user needs to explicitly get hold of the connection and execute queries against the Trino engine, for example:

```python
with context.resources.trino.get_connection() as trino_conn:
    #execute operations against Trino using the connection context manager.
```
When working with `pandas`, it is recommended to configure the `connector` property to `sqlalchemy`, in order to leverage the provided method `TrinoConnection.pandas_trino_fix` which enables Trino tables to be created from `pandas.DataFrame.to_sql()` removing the incompatible trailing semicolumns generated by pandas:

```python
df.to_sql(
    name="my_table",
    con=sqlalchemy_conn,
    method=context.resources.trino.pandas_trino_fix,
    index=False
)
```
On the other hand, reading a Trino table into a Pandas DataFrame using a `sqlalchemy` connection does not require any special fix, and can be done normally obtaining the connection as a context manager:

```python
with context.resources.trino.get_connection() as sqlalchemy_conn:
    pd.read_sql(sql=my_query, con=sqlalchemy_conn)
```

### Working with the Trino IOManager

While the Trino Resource still requires the user to explicitly interact with a Trino or SQLAlchemy connection, The IOManager is responsible for reading and writing data to and from Trino. It acts as a bridge between Trino and the user Dagster pipeline, and is responsible for ensuring that the data is properly formatted and compatible with the pipeline.

The dagster-trino IOManager has several `type_handlers` that allow the IOManager to interact with data in different formats. For example:

* `TrinoQueryTypeHandler` creates a Trino Table as a Dagster asset from a user query, or returns a query a user can execute to load an asset.
* `FilePathTypeHandler` creates a Trino Table as a Dagster asset from parquet files stored on fsspec-compatible storage (e.g. S3, GCS, HDFS), or returns the paths of parquet files backing a Trino Table on a Hive catalog.
* `ArrowTypeHandler` creates/returns Trino Table assets from/into Pyarrow Tables.

To use the IOManager, the user just needs to specify the format of the data that they want to read or write, simply by using type hints. The IOManager will then handle the conversion to and from the format specified.

### Asset I/O as Trino Queries

The [Query IO Manager](1_io_manager/query_io_manager.py) example shows how to create and load Trino Table assets as Trino Queries. 

The IOManager can load pre-existing Trino Tables as Dagster assets using Dagster `SourceAsset` class. These tables can then be referenced in queries used by Software Defined Assets. 

```python
'''
Refer to existing Trino tables even though they were created 
outside of dagster pipelines
'''
my_table = SourceAsset(key="my_table", io_manager_key='trino_io_manager')

@asset(io_manager_key="trino_io_manager")
def my_table_distinct(my_table: TrinoQuery) -> TrinoQuery:
    return f'''SELECT DISTINCT * FROM {my_table}'''
```

